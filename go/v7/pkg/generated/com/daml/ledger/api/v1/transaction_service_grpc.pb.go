// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// TransactionServiceClient is the client API for TransactionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransactionServiceClient interface {
	// Read the ledger's filtered transaction stream for a set of parties.
	GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (TransactionService_GetTransactionsClient, error)
	// Read the ledger's complete transaction tree stream for a set of parties.
	GetTransactionTrees(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (TransactionService_GetTransactionTreesClient, error)
	// Lookup a transaction tree by the ID of an event that appears within it.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	// For looking up a transaction instead of a transaction tree, please see GetFlatTransactionByEventId
	GetTransactionByEventId(ctx context.Context, in *GetTransactionByEventIdRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// Lookup a transaction tree by its ID.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	// For looking up a transaction instead of a transaction tree, please see GetFlatTransactionById
	GetTransactionById(ctx context.Context, in *GetTransactionByIdRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error)
	// Lookup a transaction by the ID of an event that appears within it.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	GetFlatTransactionByEventId(ctx context.Context, in *GetTransactionByEventIdRequest, opts ...grpc.CallOption) (*GetFlatTransactionResponse, error)
	// Lookup a transaction by its ID.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	GetFlatTransactionById(ctx context.Context, in *GetTransactionByIdRequest, opts ...grpc.CallOption) (*GetFlatTransactionResponse, error)
	// Get the current ledger end.
	// Subscriptions started with the returned offset will serve transactions created after this RPC was called.
	GetLedgerEnd(ctx context.Context, in *GetLedgerEndRequest, opts ...grpc.CallOption) (*GetLedgerEndResponse, error)
}

type transactionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTransactionServiceClient(cc grpc.ClientConnInterface) TransactionServiceClient {
	return &transactionServiceClient{cc}
}

var transactionServiceGetTransactionsStreamDesc = &grpc.StreamDesc{
	StreamName:    "GetTransactions",
	ServerStreams: true,
}

func (c *transactionServiceClient) GetTransactions(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (TransactionService_GetTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, transactionServiceGetTransactionsStreamDesc, "/com.daml.ledger.api.v1.TransactionService/GetTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServiceGetTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionService_GetTransactionsClient interface {
	Recv() (*GetTransactionsResponse, error)
	grpc.ClientStream
}

type transactionServiceGetTransactionsClient struct {
	grpc.ClientStream
}

func (x *transactionServiceGetTransactionsClient) Recv() (*GetTransactionsResponse, error) {
	m := new(GetTransactionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var transactionServiceGetTransactionTreesStreamDesc = &grpc.StreamDesc{
	StreamName:    "GetTransactionTrees",
	ServerStreams: true,
}

func (c *transactionServiceClient) GetTransactionTrees(ctx context.Context, in *GetTransactionsRequest, opts ...grpc.CallOption) (TransactionService_GetTransactionTreesClient, error) {
	stream, err := c.cc.NewStream(ctx, transactionServiceGetTransactionTreesStreamDesc, "/com.daml.ledger.api.v1.TransactionService/GetTransactionTrees", opts...)
	if err != nil {
		return nil, err
	}
	x := &transactionServiceGetTransactionTreesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TransactionService_GetTransactionTreesClient interface {
	Recv() (*GetTransactionTreesResponse, error)
	grpc.ClientStream
}

type transactionServiceGetTransactionTreesClient struct {
	grpc.ClientStream
}

func (x *transactionServiceGetTransactionTreesClient) Recv() (*GetTransactionTreesResponse, error) {
	m := new(GetTransactionTreesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var transactionServiceGetTransactionByEventIdStreamDesc = &grpc.StreamDesc{
	StreamName: "GetTransactionByEventId",
}

func (c *transactionServiceClient) GetTransactionByEventId(ctx context.Context, in *GetTransactionByEventIdRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/com.daml.ledger.api.v1.TransactionService/GetTransactionByEventId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var transactionServiceGetTransactionByIdStreamDesc = &grpc.StreamDesc{
	StreamName: "GetTransactionById",
}

func (c *transactionServiceClient) GetTransactionById(ctx context.Context, in *GetTransactionByIdRequest, opts ...grpc.CallOption) (*GetTransactionResponse, error) {
	out := new(GetTransactionResponse)
	err := c.cc.Invoke(ctx, "/com.daml.ledger.api.v1.TransactionService/GetTransactionById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var transactionServiceGetFlatTransactionByEventIdStreamDesc = &grpc.StreamDesc{
	StreamName: "GetFlatTransactionByEventId",
}

func (c *transactionServiceClient) GetFlatTransactionByEventId(ctx context.Context, in *GetTransactionByEventIdRequest, opts ...grpc.CallOption) (*GetFlatTransactionResponse, error) {
	out := new(GetFlatTransactionResponse)
	err := c.cc.Invoke(ctx, "/com.daml.ledger.api.v1.TransactionService/GetFlatTransactionByEventId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var transactionServiceGetFlatTransactionByIdStreamDesc = &grpc.StreamDesc{
	StreamName: "GetFlatTransactionById",
}

func (c *transactionServiceClient) GetFlatTransactionById(ctx context.Context, in *GetTransactionByIdRequest, opts ...grpc.CallOption) (*GetFlatTransactionResponse, error) {
	out := new(GetFlatTransactionResponse)
	err := c.cc.Invoke(ctx, "/com.daml.ledger.api.v1.TransactionService/GetFlatTransactionById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var transactionServiceGetLedgerEndStreamDesc = &grpc.StreamDesc{
	StreamName: "GetLedgerEnd",
}

func (c *transactionServiceClient) GetLedgerEnd(ctx context.Context, in *GetLedgerEndRequest, opts ...grpc.CallOption) (*GetLedgerEndResponse, error) {
	out := new(GetLedgerEndResponse)
	err := c.cc.Invoke(ctx, "/com.daml.ledger.api.v1.TransactionService/GetLedgerEnd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionServiceService is the service API for TransactionService service.
// Fields should be assigned to their respective handler implementations only before
// RegisterTransactionServiceService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type TransactionServiceService struct {
	// Read the ledger's filtered transaction stream for a set of parties.
	GetTransactions func(*GetTransactionsRequest, TransactionService_GetTransactionsServer) error
	// Read the ledger's complete transaction tree stream for a set of parties.
	GetTransactionTrees func(*GetTransactionsRequest, TransactionService_GetTransactionTreesServer) error
	// Lookup a transaction tree by the ID of an event that appears within it.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	// For looking up a transaction instead of a transaction tree, please see GetFlatTransactionByEventId
	GetTransactionByEventId func(context.Context, *GetTransactionByEventIdRequest) (*GetTransactionResponse, error)
	// Lookup a transaction tree by its ID.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	// For looking up a transaction instead of a transaction tree, please see GetFlatTransactionById
	GetTransactionById func(context.Context, *GetTransactionByIdRequest) (*GetTransactionResponse, error)
	// Lookup a transaction by the ID of an event that appears within it.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	GetFlatTransactionByEventId func(context.Context, *GetTransactionByEventIdRequest) (*GetFlatTransactionResponse, error)
	// Lookup a transaction by its ID.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	GetFlatTransactionById func(context.Context, *GetTransactionByIdRequest) (*GetFlatTransactionResponse, error)
	// Get the current ledger end.
	// Subscriptions started with the returned offset will serve transactions created after this RPC was called.
	GetLedgerEnd func(context.Context, *GetLedgerEndRequest) (*GetLedgerEndResponse, error)
}

func (s *TransactionServiceService) getTransactions(_ interface{}, stream grpc.ServerStream) error {
	if s.GetTransactions == nil {
		return status.Errorf(codes.Unimplemented, "method GetTransactions not implemented")
	}
	m := new(GetTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.GetTransactions(m, &transactionServiceGetTransactionsServer{stream})
}
func (s *TransactionServiceService) getTransactionTrees(_ interface{}, stream grpc.ServerStream) error {
	if s.GetTransactionTrees == nil {
		return status.Errorf(codes.Unimplemented, "method GetTransactionTrees not implemented")
	}
	m := new(GetTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.GetTransactionTrees(m, &transactionServiceGetTransactionTreesServer{stream})
}
func (s *TransactionServiceService) getTransactionByEventId(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	if s.GetTransactionByEventId == nil {
		return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByEventId not implemented")
	}
	in := new(GetTransactionByEventIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetTransactionByEventId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/com.daml.ledger.api.v1.TransactionService/GetTransactionByEventId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetTransactionByEventId(ctx, req.(*GetTransactionByEventIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *TransactionServiceService) getTransactionById(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	if s.GetTransactionById == nil {
		return nil, status.Errorf(codes.Unimplemented, "method GetTransactionById not implemented")
	}
	in := new(GetTransactionByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetTransactionById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/com.daml.ledger.api.v1.TransactionService/GetTransactionById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetTransactionById(ctx, req.(*GetTransactionByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *TransactionServiceService) getFlatTransactionByEventId(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	if s.GetFlatTransactionByEventId == nil {
		return nil, status.Errorf(codes.Unimplemented, "method GetFlatTransactionByEventId not implemented")
	}
	in := new(GetTransactionByEventIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetFlatTransactionByEventId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/com.daml.ledger.api.v1.TransactionService/GetFlatTransactionByEventId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetFlatTransactionByEventId(ctx, req.(*GetTransactionByEventIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *TransactionServiceService) getFlatTransactionById(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	if s.GetFlatTransactionById == nil {
		return nil, status.Errorf(codes.Unimplemented, "method GetFlatTransactionById not implemented")
	}
	in := new(GetTransactionByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetFlatTransactionById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/com.daml.ledger.api.v1.TransactionService/GetFlatTransactionById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetFlatTransactionById(ctx, req.(*GetTransactionByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *TransactionServiceService) getLedgerEnd(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	if s.GetLedgerEnd == nil {
		return nil, status.Errorf(codes.Unimplemented, "method GetLedgerEnd not implemented")
	}
	in := new(GetLedgerEndRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetLedgerEnd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/com.daml.ledger.api.v1.TransactionService/GetLedgerEnd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetLedgerEnd(ctx, req.(*GetLedgerEndRequest))
	}
	return interceptor(ctx, in, info, handler)
}

type TransactionService_GetTransactionsServer interface {
	Send(*GetTransactionsResponse) error
	grpc.ServerStream
}

type transactionServiceGetTransactionsServer struct {
	grpc.ServerStream
}

func (x *transactionServiceGetTransactionsServer) Send(m *GetTransactionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

type TransactionService_GetTransactionTreesServer interface {
	Send(*GetTransactionTreesResponse) error
	grpc.ServerStream
}

type transactionServiceGetTransactionTreesServer struct {
	grpc.ServerStream
}

func (x *transactionServiceGetTransactionTreesServer) Send(m *GetTransactionTreesResponse) error {
	return x.ServerStream.SendMsg(m)
}

// RegisterTransactionServiceService registers a service implementation with a gRPC server.
func RegisterTransactionServiceService(s grpc.ServiceRegistrar, srv *TransactionServiceService) {
	sd := grpc.ServiceDesc{
		ServiceName: "com.daml.ledger.api.v1.TransactionService",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "GetTransactionByEventId",
				Handler:    srv.getTransactionByEventId,
			},
			{
				MethodName: "GetTransactionById",
				Handler:    srv.getTransactionById,
			},
			{
				MethodName: "GetFlatTransactionByEventId",
				Handler:    srv.getFlatTransactionByEventId,
			},
			{
				MethodName: "GetFlatTransactionById",
				Handler:    srv.getFlatTransactionById,
			},
			{
				MethodName: "GetLedgerEnd",
				Handler:    srv.getLedgerEnd,
			},
		},
		Streams: []grpc.StreamDesc{
			{
				StreamName:    "GetTransactions",
				Handler:       srv.getTransactions,
				ServerStreams: true,
			},
			{
				StreamName:    "GetTransactionTrees",
				Handler:       srv.getTransactionTrees,
				ServerStreams: true,
			},
		},
		Metadata: "com/daml/ledger/api/v1/transaction_service.proto",
	}

	s.RegisterService(&sd, nil)
}

// NewTransactionServiceService creates a new TransactionServiceService containing the
// implemented methods of the TransactionService service in s.  Any unimplemented
// methods will result in the gRPC server returning an UNIMPLEMENTED status to the client.
// This includes situations where the method handler is misspelled or has the wrong
// signature.  For this reason, this function should be used with great care and
// is not recommended to be used by most users.
func NewTransactionServiceService(s interface{}) *TransactionServiceService {
	ns := &TransactionServiceService{}
	if h, ok := s.(interface {
		GetTransactions(*GetTransactionsRequest, TransactionService_GetTransactionsServer) error
	}); ok {
		ns.GetTransactions = h.GetTransactions
	}
	if h, ok := s.(interface {
		GetTransactionTrees(*GetTransactionsRequest, TransactionService_GetTransactionTreesServer) error
	}); ok {
		ns.GetTransactionTrees = h.GetTransactionTrees
	}
	if h, ok := s.(interface {
		GetTransactionByEventId(context.Context, *GetTransactionByEventIdRequest) (*GetTransactionResponse, error)
	}); ok {
		ns.GetTransactionByEventId = h.GetTransactionByEventId
	}
	if h, ok := s.(interface {
		GetTransactionById(context.Context, *GetTransactionByIdRequest) (*GetTransactionResponse, error)
	}); ok {
		ns.GetTransactionById = h.GetTransactionById
	}
	if h, ok := s.(interface {
		GetFlatTransactionByEventId(context.Context, *GetTransactionByEventIdRequest) (*GetFlatTransactionResponse, error)
	}); ok {
		ns.GetFlatTransactionByEventId = h.GetFlatTransactionByEventId
	}
	if h, ok := s.(interface {
		GetFlatTransactionById(context.Context, *GetTransactionByIdRequest) (*GetFlatTransactionResponse, error)
	}); ok {
		ns.GetFlatTransactionById = h.GetFlatTransactionById
	}
	if h, ok := s.(interface {
		GetLedgerEnd(context.Context, *GetLedgerEndRequest) (*GetLedgerEndResponse, error)
	}); ok {
		ns.GetLedgerEnd = h.GetLedgerEnd
	}
	return ns
}

// UnstableTransactionServiceService is the service API for TransactionService service.
// New methods may be added to this interface if they are added to the service
// definition, which is not a backward-compatible change.  For this reason,
// use of this type is not recommended.
type UnstableTransactionServiceService interface {
	// Read the ledger's filtered transaction stream for a set of parties.
	GetTransactions(*GetTransactionsRequest, TransactionService_GetTransactionsServer) error
	// Read the ledger's complete transaction tree stream for a set of parties.
	GetTransactionTrees(*GetTransactionsRequest, TransactionService_GetTransactionTreesServer) error
	// Lookup a transaction tree by the ID of an event that appears within it.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	// For looking up a transaction instead of a transaction tree, please see GetFlatTransactionByEventId
	GetTransactionByEventId(context.Context, *GetTransactionByEventIdRequest) (*GetTransactionResponse, error)
	// Lookup a transaction tree by its ID.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	// For looking up a transaction instead of a transaction tree, please see GetFlatTransactionById
	GetTransactionById(context.Context, *GetTransactionByIdRequest) (*GetTransactionResponse, error)
	// Lookup a transaction by the ID of an event that appears within it.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	GetFlatTransactionByEventId(context.Context, *GetTransactionByEventIdRequest) (*GetFlatTransactionResponse, error)
	// Lookup a transaction by its ID.
	// Returns ``NOT_FOUND`` if no such transaction exists.
	GetFlatTransactionById(context.Context, *GetTransactionByIdRequest) (*GetFlatTransactionResponse, error)
	// Get the current ledger end.
	// Subscriptions started with the returned offset will serve transactions created after this RPC was called.
	GetLedgerEnd(context.Context, *GetLedgerEndRequest) (*GetLedgerEndResponse, error)
}
